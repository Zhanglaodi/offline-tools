<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ç½‘é¡µä¸²å£å·¥å…· (Web Serial)</title>
    <style>
        :root {
            --bg: #0f1117;
            --fg: #e6edf3;
            --muted: #8b949e;
            --accent: #2f81f7;
            --ok: #2ea043;
            --warn: #d29922;
            --err: #f85149;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 12px;
            font: 14px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
            background: var(--bg);
            color: var(--fg);
        }

        h3 {
            margin: 4px 0 12px;
        }

        fieldset {
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 10px 12px;
            margin: 0 0 10px;
        }

        legend {
            color: var(--muted);
            padding: 0 6px;
        }

        label {
            margin-right: 8px;
        }

        select,
        input[type="number"],
        input[type="text"] {
            background: #161b22;
            border: 1px solid #30363d;
            color: var(--fg);
            border-radius: 8px;
            padding: 6px 8px;
        }

        button {
            background: #21262d;
            color: var(--fg);
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 6px 10px;
            cursor: pointer;
        }

        button:hover {
            border-color: #6e7681;
        }

        button.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        button.on {
            background: var(--ok);
            border-color: var(--ok);
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .grow {
            flex: 1 1 auto;
        }

        #rx {
            width: 100%;
            height: 340px;
            background: #0b0e14;
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 8px;
            overflow: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #tx {
            width: 100%;
            height: 90px;
            background: #0b0e14;
            border: 1px solid #30363d;
            border-radius: 10px;
            padding: 8px;
            white-space: pre;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            background: #161b22;
            border: 1px solid #30363d;
            color: var(--muted);
        }

        .badge.ok {
            color: var(--ok);
            border-color: var(--ok);
        }

        .badge.warn {
            color: var(--warn);
            border-color: var(--warn);
        }

        .badge.err {
            color: var(--err);
            border-color: var(--err);
        }

        .switch {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .foot {
            color: var(--muted);
            font-size: 12px;
            margin-top: 6px;
        }
    </style>
</head>

<body>
    <h3>ç½‘é¡µä¸²å£å·¥å…· (Web Serial)</h3>

    <fieldset>
        <legend>è¿æ¥ä¸ä¸²å£å‚æ•°</legend>
        <div class="row">
            <label>æ³¢ç‰¹ç‡
                <input id="baud" type="number" min="50" value="115200" step="50" style="width:110px;">
            </label>
            <label>æ•°æ®ä½
                <select id="dataBits">
                    <option>8</option>
                    <option>7</option>
                </select>
            </label>
            <label>åœæ­¢ä½
                <select id="stopBits">
                    <option value="1">1</option>
                    <option value="2">2</option>
                </select>
            </label>
            <label>å¥‡å¶æ ¡éªŒ
                <select id="parity">
                    <option value="none">none</option>
                    <option value="even">even</option>
                    <option value="odd">odd</option>
                </select>
            </label>
            <label>æµæ§
                <select id="flow">
                    <option value="none">none</option>
                    <option value="hardware">hardware (RTS/CTS)</option>
                </select>
            </label>
            <button id="btnConnect" class="primary">è¿æ¥</button>
            <button id="btnDisconnect">æ–­å¼€</button>
            <span id="portStat" class="badge">æœªè¿æ¥</span>
        </div>
        <div class="row">
            <div class="switch">
                <button id="btnDTR">DTR</button>
                <button id="btnRTS">RTS</button>
                <span id="sigCTS" class="badge">CTS: ?</span>
                <span id="sigDCD" class="badge">DCD: ?</span>
                <span id="sigRI" class="badge">RI: ?</span>
            </div>
        </div>
    </fieldset>

    <fieldset>
        <legend>æ¥æ”¶åŒº</legend>
        <div class="row">
            <label><input type="checkbox" id="ts" checked> æ˜¾ç¤ºæ—¶é—´æˆ³</label>
            <label><input type="checkbox" id="hexRx"> ä»¥ Hex æ˜¾ç¤º</label>
            <label><input type="checkbox" id="autoscroll" checked> è‡ªåŠ¨æ»šåŠ¨</label>
            <button id="btnClear">æ¸…ç©º</button>
            <button id="btnSave">ä¿å­˜æ—¥å¿—</button>
        </div>
        <div id="rx"></div>
    </fieldset>

    <fieldset>
        <legend>å‘é€åŒº</legend>
        <div class="row">
            <label><input type="checkbox" id="hexTx"> Hex å‘é€</label>
            <label>è¡Œç»“å°¾
                <select id="eol">
                    <option value="none">æ— </option>
                    <option value="cr">CR \\r</option>
                    <option value="lf">LF \\n</option>
                    <option value="crlf" selected>CRLF \\r\\n</option>
                </select>
            </label>
            <label>å‘¨æœŸå‘é€
                <input id="interval" type="number" min="0" value="0" style="width:80px;"> ms (0 å…³é—­)
            </label>
            <button id="btnSend">å‘é€</button>
            <button id="btnStopAuto">åœæ­¢å‘¨æœŸ</button>
        </div>
        <textarea id="tx" placeholder="åœ¨æ­¤è¾“å…¥è¦å‘é€çš„å†…å®¹ã€‚å‹¾é€‰ Hex å‘é€æ—¶ï¼Œæ”¯æŒ '01 02 0A FF' æˆ– '01020AFF' æ ¼å¼ã€‚"></textarea>
    </fieldset>

    <div class="foot">æç¤ºï¼šæ­¤å·¥å…·éœ€ Chrome/Edge (æ”¯æŒ Web Serial)ã€‚å¯è®¾ç½® DTR/RTSã€è¯»å– CTS/DCD/RI çŠ¶æ€ï¼›æµæ§é€‰æ‹© hardware æ—¶å¯ç”¨ RTS/CTSã€‚</div>

    <script>

        /* ======= Web Serial å…¨é‡é€»è¾‘ ======= */
        let port, reader, writer;
        let keepReading = false;
        let dtr = false, rts = false;
        let dec = new TextDecoder();        // æµå¼è§£ç 
        let enc = new TextEncoder();
        let rxBinaryBuf = new Uint8Array(0); // HEX æ¨¡å¼æ‹¼åŒ…
        let rxLineBuf = "";                // ASCII æ¨¡å¼æŒ‰è¡Œ
        let flushTimer = null;               // ç²˜åˆ/å…œåº•åˆ·æ–°çš„è®¡æ—¶å™¨
        let saveBuf = [];                    // ä¿å­˜æ—¥å¿—
        let sigPollTimer = null;             // ä¿¡å·è½®è¯¢è®¡æ—¶å™¨
        let autoTimer = null;                // å‘¨æœŸå‘é€è®¡æ—¶å™¨

        /* --------- ä¾¿æ·é€‰æ‹©å™¨ / DOM --------- */
        const $ = s => document.querySelector(s);
        const rxBox = $("#rx");

        /* --------- å·¥å…·å‡½æ•° --------- */
        function rxPrint(msg, cls) {
            const tsOn = $("#ts").checked;
            const t = new Date();
            const hh = String(t.getHours()).padStart(2, "0");
            const mm = String(t.getMinutes()).padStart(2, "0");
            const ss = String(t.getSeconds()).padStart(2, "0");
            const ms = String(t.getMilliseconds()).padStart(3, "0");
            const line = (tsOn ? `[${hh}:${mm}:${ss}.${ms}] ` : "") + msg;
            const div = document.createElement("div");
            if (cls) div.className = cls;
            div.textContent = line;
            rxBox.appendChild(div);
            if ($("#autoscroll").checked) rxBox.scrollTop = rxBox.scrollHeight;
            saveBuf.push(line);
            if (saveBuf.length > 50000) saveBuf.shift();
        }
        function toHex(u8) { return Array.from(u8, b => b.toString(16).padStart(2, '0')).join(' '); }
        function fromHex(str) {
            const clean = str.replace(/[^0-9a-fA-F]/g, '');
            if (clean.length % 2) throw new Error("Hex é•¿åº¦éœ€ä¸ºå¶æ•°");
            const out = new Uint8Array(clean.length / 2);
            for (let i = 0; i < clean.length; i += 2) out[i / 2] = parseInt(clean.slice(i, i + 2), 16);
            return out;
        }
        function concatU8(a, b) {
            const out = new Uint8Array(a.length + b.length);
            out.set(a, 0); out.set(b, a.length);
            return out;
        }
        function badge(el, text, cls) {
            el.textContent = text;
            el.className = "badge " + (cls || "");
        }

        /* --------- æµè§ˆå™¨èƒ½åŠ›æ£€æµ‹ --------- */
        (function supportCheck() {
            if (!("serial" in navigator)) {
                rxPrint("âŒ å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIï¼Œè¯·ä½¿ç”¨ Chrome/Edgeã€‚", "err");
            }
        })();

        /* --------- ä¸²å£è¿æ¥/æ–­å¼€ --------- */
        async function connect() {
            try {
                port = await navigator.serial.requestPort();
                const opt = {
                    baudRate: Number($("#baud").value) || 115200,
                    dataBits: Number($("#dataBits").value) || 8,
                    stopBits: Number($("#stopBits").value) || 1,
                    parity: $("#parity").value,            // 'none' | 'even' | 'odd'
                    flowControl: $("#flow").value          // 'none' | 'hardware'
                };
                await port.open(opt);
                writer = port.writable.getWriter();
                keepReading = true;

                $("#portStat").textContent = "å·²è¿æ¥";
                $("#portStat").className = "badge ok";
                rxPrint(`âœ… å·²è¿æ¥ï¼Œå‚æ•°: ${opt.baudRate}/${opt.dataBits}/${opt.parity}/${opt.stopBits} flow=${opt.flowControl}`, "ok");

                // åˆå§‹åŒ– DTR/RTS
                await port.setSignals({ dataTerminalReady: dtr, requestToSend: rts });

                // è½®è¯¢ç¡¬ä»¶ä¿¡å·ï¼ˆéƒ¨åˆ†å¹³å°å¯èƒ½ä¸æ”¯æŒ getSignalsï¼‰
                if (sigPollTimer) clearInterval(sigPollTimer);
                sigPollTimer = setInterval(updateSignalsBadge, 500);

                readLoop();
            } catch (e) {
                rxPrint("è¿æ¥å¤±è´¥: " + e.message, "err");
            }
        }

        async function disconnect() {
            try {
                keepReading = false;
                if (flushTimer) { clearTimeout(flushTimer); flushTimer = null; }
                if (sigPollTimer) { clearInterval(sigPollTimer); sigPollTimer = null; }
                if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }

                if (reader) { try { await reader.cancel(); } catch { } try { reader.releaseLock(); } catch { } reader = null; }
                if (writer) { try { writer.releaseLock(); } catch { } writer = null; }
                if (port) { try { await port.close(); } catch { } port = null; }

                $("#portStat").textContent = "æœªè¿æ¥";
                $("#portStat").className = "badge";
                rxPrint("ğŸ”Œ å·²æ–­å¼€");
            } catch (e) {
                rxPrint("æ–­å¼€å¤±è´¥: " + e.message, "err");
            }
        }

        /* --------- è¯»å¾ªç¯ï¼ˆæ‹†åŒ…/æŒ‰è¡Œ/ç²˜åˆï¼‰ --------- */
        async function readLoop() {
            while (port && port.readable && keepReading) {
                reader = port.readable.getReader();
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        if (!value || value.length === 0) continue;

                        if ($("#hexRx").checked) {
                            // HEX æ˜¾ç¤ºï¼šåˆå¹¶ç‰‡æ®µï¼Œå®šæ—¶åˆ·å‡ºï¼ˆé¿å…ä¸€è¡Œè¢«åˆ‡æ–­ï¼‰
                            rxBinaryBuf = concatU8(rxBinaryBuf, value);
                            if (flushTimer) clearTimeout(flushTimer);
                            flushTimer = setTimeout(() => {
                                if (rxBinaryBuf.length) {
                                    rxPrint("â¬… " + toHex(rxBinaryBuf));
                                    rxBinaryBuf = new Uint8Array(0);
                                }
                            }, 5); // 5~10ms ç»éªŒå€¼
                        } else {
                            // ASCIIï¼šæµå¼è§£ç  + ä»¥æ¢è¡Œåˆ‡åˆ†
                            rxLineBuf += dec.decode(value, { stream: true });
                            rxLineBuf = rxLineBuf.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

                            let idx;
                            while ((idx = rxLineBuf.indexOf('\n')) >= 0) {
                                const line = rxLineBuf.slice(0, idx);
                                rxLineBuf = rxLineBuf.slice(idx + 1);
                                rxPrint("â¬… " + line);
                            }
                            // å…œåº•ï¼šè‹¥è¿Ÿè¿Ÿæ— æ¢è¡Œï¼Œ10ms åä¹Ÿåˆ·ä¸€æ¬¡ï¼Œé¿å…åŠè¡Œæ‚¬æŒ‚
                            if (flushTimer) clearTimeout(flushTimer);
                            flushTimer = setTimeout(() => {
                                if (rxLineBuf.length) {
                                    rxPrint("â¬… " + rxLineBuf);
                                    rxLineBuf = "";
                                }
                            }, 10);
                        }
                    }
                } catch (e) {
                    rxPrint("è¯»å–é”™è¯¯: " + e.message, "warn");
                } finally {
                    try { reader.releaseLock(); } catch { }
                }
            }
        }

        /* --------- å‘é€ --------- */
        async function sendOnce() {
            if (!writer) { rxPrint("æœªè¿æ¥ä¸²å£", "warn"); return; }
            try {
                let payload;
                if ($("#hexTx").checked) {
                    payload = fromHex($("#tx").value);
                } else {
                    let s = $("#tx").value;
                    const eol = $("#eol").value;
                    if (eol === "cr") s += "\r";
                    else if (eol === "lf") s += "\n";
                    else if (eol === "crlf") s += "\r\n";
                    payload = enc.encode(s);
                }
                await writer.write(payload);
                rxPrint("â¡ å·²å‘é€ " + ($("#hexTx").checked ? (payload.length + "B HEX") : (payload.length + "B ASCII")));
            } catch (e) {
                rxPrint("å‘é€å¤±è´¥: " + e.message, "err");
            }
        }

        /* --------- ä¿å­˜æ—¥å¿— --------- */
        function saveLog() {
            const blob = new Blob([saveBuf.join("\n")], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `serial_log_${Date.now()}.txt`;
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
        }

        /* --------- ç¡¬ä»¶ä¿¡å· --------- */
        async function updateSignalsBadge() {
            if (!port) return;
            try {
                const sig = await port.getSignals(); // {clearToSend, dataCarrierDetect, ringIndicator}
                badge($("#sigCTS"), "CTS: " + (sig.clearToSend ? "1" : "0"), sig.clearToSend ? "ok" : "");
                badge($("#sigDCD"), "DCD: " + (sig.dataCarrierDetect ? "1" : "0"), sig.dataCarrierDetect ? "ok" : "");
                badge($("#sigRI"), "RI: " + (sig.ringIndicator ? "1" : "0"), sig.ringIndicator ? "ok" : "");
            } catch (e) {
                // æŸäº›å¹³å°å¯èƒ½ä¸æ”¯æŒï¼Œå¿½ç•¥å³å¯
            }
        }

        /* --------- äº‹ä»¶ç»‘å®š --------- */
        $("#btnConnect").onclick = connect;
        $("#btnDisconnect").onclick = disconnect;
        $("#btnClear").onclick = () => { rxBox.textContent = ""; saveBuf.length = 0; };
        $("#btnSave").onclick = saveLog;
        $("#btnSend").onclick = sendOnce;
        $("#btnStopAuto").onclick = () => { if (autoTimer) { clearInterval(autoTimer); autoTimer = null; rxPrint("â¹ åœæ­¢å‘¨æœŸå‘é€"); } };
        $("#interval").addEventListener("change", () => {
            const iv = Number($("#interval").value) || 0;
            if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
            if (iv > 0) {
                autoTimer = setInterval(() => { sendOnce(); }, iv);
                rxPrint("â± å¯åŠ¨å‘¨æœŸå‘é€: " + iv + " ms");
            }
        });
        $("#btnDTR").onclick = async () => {
            dtr = !dtr;
            try { if (port) await port.setSignals({ dataTerminalReady: dtr }); } catch { }
            $("#btnDTR").classList.toggle("on", dtr);
        };
        $("#btnRTS").onclick = async () => {
            rts = !rts;
            try { if (port) await port.setSignals({ requestToSend: rts }); } catch { }
            $("#btnRTS").classList.toggle("on", rts);
        };

        /* --------- å¿«æ·é”® --------- */
        // Ctrl/âŒ˜ + Enter å‘é€
        document.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) { sendOnce(); }
        });
    </script>
</body>

</html>