import sys
import re
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QPushButton, QLabel, QFileDialog, QComboBox, QMessageBox
)

# BLF支持
try:
    import can
    BLF_AVAILABLE = True
except ImportError:
    BLF_AVAILABLE = False
import python_can

class ASCMessage:
    def __init__(self, timestamp, can_id, data):
        self.timestamp = timestamp
        self.can_id = can_id
        self.data = data
def blf_to_asc(blf_path, asc_path):
    if not BLF_AVAILABLE:
        raise RuntimeError('请先安装python-can库: pip install python-can')
    with can.BLFReader(blf_path) as log, open(asc_path, 'w', encoding='utf-8') as f:
        f.write('// ASC log generated from BLF\n')
        for msg in log:
            if hasattr(msg, 'timestamp') and hasattr(msg, 'arbitration_id') and hasattr(msg, 'data'):
                # BLF时间戳为绝对秒
                timestamp = msg.timestamp
                can_id = f"{msg.arbitration_id:X}"
                data = ' '.join(f"{b:02X}" for b in msg.data)
                dlc = len(msg.data)
                # ASC格式：时间戳 1 CANID Rx d DLC DATA
                f.write(f"{timestamp:.6f} 1 {can_id} Rx d {dlc} {data}\n")

class TRCMessage:
    def __init__(self, timestamp, can_id, data):
        self.timestamp = timestamp
        self.can_id = can_id
        self.data = data

def parse_asc(file_path):
    messages = []
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
                # 支持带通道号的ASC格式
            m = re.match(r"(\d+\.\d+)\s+\d+\s+([\w]+)\s+Rx\s+d\s+(\d+)\s+([\dA-Fa-f ]+)", line)
            if m:
                timestamp = float(m.group(1))
                can_id = m.group(2)
                data = m.group(4).strip().split()
                messages.append(ASCMessage(timestamp, can_id, data))
    print('parse_asc:', messages)
    return messages

def write_trc(messages, file_path):
    with open(file_path, 'w', encoding='utf-8') as f:
        # 标准TRC头部
        f.write(";TRC log generated by ASC<->TRC Converter\n")
        f.write(";   Date: \n")
        f.write(";   Time: \n")
        f.write(";   Channels: 1\n")
        f.write(";   Columns:  Time  Chn  Dir  ID  DLC  Data\n")
        f.write("$HEX\n")
        for msg in messages:
            # 假设通道为1，方向为Rx
            # ID字段为8位大写16进制，前补0
            try:
                can_id = int(msg.can_id, 16) if msg.can_id.startswith(('0x', '0X')) else int(msg.can_id, 16)
            except Exception:
                can_id = int(msg.can_id)
            id_str = f"{can_id:08X}"
            data_str = ' '.join([f"{int(b,16):02X}" for b in msg.data])
            # 字段顺序：时间戳  通道  方向  ID  DLC  数据
            f.write(f"{msg.timestamp:.6f}\t1\tRx\t{id_str}\t{len(msg.data)}\t{data_str}\n")

def parse_trc(file_path):
    messages = []
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
        for line in f:
            if line.startswith(';') or not line.strip():
                continue
            m = re.match(r"(\d+\.\d+)\t([\w]+)\tRx\td\t(\d+)\t([\dA-Fa-f ]+)", line)
            if m:
                timestamp = float(m.group(1))
                can_id = m.group(2)
                data = m.group(4).strip().split()
                messages.append(TRCMessage(timestamp, can_id, data))
    return messages

def write_asc(messages, file_path):
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write("// ASC log generated by ASC<->TRC Converter\n")
        for msg in messages:
            data_str = ' '.join(msg.data)
            f.write(f"{msg.timestamp:.6f} {msg.can_id} Rx d {len(msg.data)} {data_str}\n")

class ConverterUI(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ASC <-> TRC 转换工具")
        self.resize(400, 200)
        layout = QVBoxLayout()
        self.setLayout(layout)

        self.label = QLabel("请选择要转换的文件：")
        layout.addWidget(self.label)

        self.file_btn = QPushButton("选择文件")
        self.file_btn.clicked.connect(self.choose_file)
        layout.addWidget(self.file_btn)

        self.format_combo = QComboBox()
        self.format_combo.addItems(["ASC转TRC", "TRC转ASC", "BLF转ASC"])
        layout.addWidget(self.format_combo)

        self.convert_btn = QPushButton("开始转换")
        self.convert_btn.clicked.connect(self.convert)
        layout.addWidget(self.convert_btn)

        self.input_path = None

    def choose_file(self):
        path, _ = QFileDialog.getOpenFileName(self, "选择文件", "", "ASC/TRC Files (*.asc *.trc);;All Files (*)")
        if path:
            self.input_path = path
            self.label.setText(f"已选择文件: {path}")

    def convert(self):
        if not self.input_path:
            QMessageBox.warning(self, "错误", "请先选择文件！")
            return
        out_path, _ = QFileDialog.getSaveFileName(self, "保存为", "", "ASC/TRC Files (*.asc *.trc);;All Files (*)")
        if not out_path:
            return
        try:
            idx = self.format_combo.currentIndex()
            if idx == 0:
                # ASC转TRC
                msgs = parse_asc(self.input_path)
                write_trc(msgs, out_path)
            elif idx == 1:
                # TRC转ASC
                msgs = parse_trc(self.input_path)
                write_asc(msgs, out_path)
            elif idx == 2:
                # BLF转ASC
                blf_to_asc(self.input_path, out_path)
            QMessageBox.information(self, "成功", "转换完成！")
        except Exception as e:
            QMessageBox.critical(self, "转换失败", str(e))

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = ConverterUI()
    win.show()
    sys.exit(app.exec_())
